# RandomWalkInfoBoard.gd
# Info board for Random Walk algorithm
extends AlgorithmInfoBoardBase

# Preload visualization
const RandomWalkVis = preload("res://commons/infoboards_3d/visualizations/RandomWalkVisualization.gd")

func initialize_content() -> void:
	"""Set up content pages for Random Walk"""
	board_title = "Random Walk"
	category_color = Color(0.8, 0.5, 0.9, 1.0)  # Purple for randomness

	page_content = [
		{
			"title": "Random Walk - Introduction",
			"text": [
				"A random walk is a mathematical object that describes a path consisting of a succession of random steps.",
				"It's one of the fundamental concepts in probability theory and has applications in physics, biology, economics, and computer science.",
				"",
				"In 2D space, at each step the walker moves in a random direction: up, down, left, right, or stays in place.",
				"Watch the visualization to see how random walks create unpredictable but structured patterns over time.",
				"",
				"The beauty of random walks lies in their simplicity - each step is random, yet the overall behavior exhibits predictable statistical properties.",
				"Despite the randomness at each individual step, the aggregate behavior follows well-defined mathematical patterns.",
				"",
				"HISTORICAL CONTEXT:",
				"Random walks were first studied by mathematician Karl Pearson in 1905, who described them in the context of mosquito movement.",
				"He posed the question: 'A man starts from a point O and walks l yards in a straight line; he then turns through any angle whatever and walks another l yards in a second straight line. He repeats this process n times. I require the probability that after these n stretches he is at a distance between r and r+dr from his starting point, O.'",
				"",
				"Since then, they've become one of the most important concepts in stochastic processes.",
				"Albert Einstein's 1905 paper on Brownian motion used random walk theory to prove the existence of atoms.",
				"This same year, Louis Bachelier used random walks to model stock market fluctuations in his PhD thesis.",
				"",
				"FUNDAMENTAL PROPERTIES:",
				"• Each step is completely independent of previous steps",
				"• Direction is chosen uniformly at random from available options",
				"• Step size can be constant (simple random walk) or variable (Lévy flight)",
				"• Long-term behavior is predictable despite short-term randomness",
				"• The expected distance from origin grows as √N where N is the number of steps",
				"• Returns to origin are guaranteed in 1D and 2D, but only ~34% likely in 3D",
				"",
				"MATHEMATICAL ELEGANCE:",
				"What makes random walks fascinating is the interplay between microscopic randomness and macroscopic order.",
				"At the small scale, every step is completely unpredictable.",
				"But zoom out, and patterns emerge: probability distributions, diffusion rates, return probabilities.",
				"",
				"This duality appears everywhere in nature:",
				"- Gas molecules move randomly, yet heat flows predictably",
				"- Individual ants wander chaotically, yet colonies optimize food gathering",
				"- Stock prices jump erratically, yet markets follow statistical trends",
				"- Quantum particles tunnel randomly, yet semiconductors work reliably",
				"",
				"DIMENSIONALITY MATTERS:",
				"The dimension of space profoundly affects random walk behavior:",
				"",
				"1D Random Walk:",
				"• Guaranteed to return to origin (recurrent)",
				"• Expected return time is infinite!",
				"• Will visit every point infinitely many times",
				"",
				"2D Random Walk:",
				"• Also guaranteed to return to origin",
				"• Expected return time is still infinite",
				"• Polya proved this in 1921",
				"",
				"3D Random Walk:",
				"• Only ~34% chance of returning to origin (transient)",
				"• Walker likely escapes to infinity",
				"• This affects diffusion in 3D space",
				"",
				"Higher dimensions become even more transient.",
				"In 4D and above, return probability drops below 20%!",
				"",
				"APPLICATIONS IN GAMES AND SIMULATIONS:",
				"This makes random walks perfect for modeling everything from stock prices to animal foraging patterns to quantum particle behavior.",
				"Game developers use them for NPC behavior, procedural generation, particle effects, and AI exploration.",
				"Physics simulators use them for Brownian motion, diffusion, and heat transfer.",
				"",
				"SCROLL DOWN TO SEE MORE APPLICATIONS!",
				"",
				"(This is test content to demonstrate scrolling in VR. The ScrollContainer should allow you to scroll through this long text using your VR controller.)"
			],
			"visualization": "random_walk_2d"
		},
		{
			"title": "Mathematical Foundation",
			"text": [
				"BASIC MATHEMATICAL DESCRIPTION:",
				"A random walk can be described mathematically as:",
				"Position at step n: P(n) = P(n-1) + Step(n)",
				"Where Step(n) is a random vector chosen from a set of possible moves.",
				"",
				"In discrete time, we can write:",
				"X_n = X_0 + ∑(i=1 to n) S_i",
				"where S_i are independent, identically distributed random variables.",
				"",
				"DISPLACEMENT AND DISTANCE:",
				"Expected displacement from origin after N steps:",
				"E[|X_N|] ∝ √N",
				"",
				"This square root relationship is fundamental!",
				"It means the walker tends to drift away from the starting point, but slowly.",
				"To get twice as far away takes four times as many steps.",
				"",
				"The root-mean-square distance is:",
				"√(E[|X_N|²]) = σ√N",
				"where σ is the step size standard deviation.",
				"",
				"PROBABILITY DISTRIBUTIONS:",
				"After many steps, the position follows a Gaussian distribution (Central Limit Theorem):",
				"P(x,y,t) = (1/4πDt) exp(-(x² + y²)/4Dt)",
				"where D is the diffusion coefficient.",
				"",
				"This is the same equation that describes heat diffusion!",
				"",
				"RETURN PROBABILITIES:",
				"The probability of eventually returning to the origin:",
				"• 1D: 100% (guaranteed to return)",
				"  Proof uses reflection principle",
				"",
				"• 2D: 100% (guaranteed to return)",
				"  Proved by George Polya in 1921",
				"  But expected return time is infinite!",
				"",
				"• 3D: ~34.05% (might never return!)",
				"  Exact value: 1 - 1/u₃ where u₃ ≈ 1.516",
				"",
				"• 4D and higher: Even lower return probability",
				"  Approaches 0 as dimension increases",
				"",
				"RECURRENCE VS TRANSIENCE:",
				"A random walk is 'recurrent' if it returns to origin with probability 1.",
				"It's 'transient' if there's a non-zero probability of never returning.",
				"",
				"The critical dimension is 2:",
				"• Dimensions ≤ 2: Recurrent",
				"• Dimensions ≥ 3: Transient",
				"",
				"GENERATING FUNCTIONS:",
				"The probability generating function for a 1D random walk:",
				"G(z) = ∑ P_n z^n",
				"where P_n is the probability of being at origin after n steps.",
				"",
				"MARTINGALE PROPERTIES:",
				"A random walk is a martingale, meaning:",
				"E[X_n | X_0, X_1, ..., X_(n-1)] = X_(n-1)",
				"",
				"This 'fair game' property makes random walks useful in:",
				"• Option pricing (Black-Scholes model)",
				"• Gambling theory",
				"• Statistical physics",
				"",
				"FIRST PASSAGE TIME:",
				"The expected time to first reach distance d from origin:",
				"T_d ∝ d² (in all dimensions!)",
				"",
				"This has profound implications for search algorithms and diffusion-limited reactions.",
				"",
				"(Scroll to see implementation details on the next page)"
			],
			"visualization": "random_walk_2d"
		},
		{
			"title": "Implementation in Godot",
			"text": [
				"Here's how to implement a simple 2D random walk:",
				"",
				"var position = Vector2.ZERO",
				"func step():",
				"    var direction = Vector2(",
				"        randi_range(-1, 1),",
				"        randi_range(-1, 1)",
				"    )",
				"    position += direction * step_size",
				"",
				"This creates movement in 8 possible directions (including diagonals).",
				"For a 4-direction walk, ensure only one component is non-zero at a time."
			],
			"visualization": "random_walk_2d"
		},
		{
			"title": "Applications",
			"text": [
				"Random walks appear everywhere in computer science and game development:",
				"",
				"1. Procedural Generation:",
				"   • Dungeon layouts and cave systems",
				"   • Terrain features and river paths",
				"   • Organic-looking patterns",
				"   • Maze generation algorithms",
				"   • Natural-looking paths and roads",
				"",
				"2. AI & Behavior:",
				"   • NPC wandering behavior",
				"   • Particle system movements",
				"   • Exploration algorithms",
				"   • Enemy patrol patterns",
				"   • Wildlife simulation",
				"   • Crowd movement",
				"",
				"3. Simulations:",
				"   • Brownian motion (physics)",
				"   • Diffusion processes",
				"   • Stock price models (finance)",
				"   • Heat distribution",
				"   • Chemical reactions",
				"   • Quantum mechanics",
				"",
				"4. Graphics & Effects:",
				"   • Organic texture generation",
				"   • Lightning and electricity effects",
				"   • Crack propagation",
				"   • Erosion patterns",
				"",
				"5. Machine Learning:",
				"   • Stochastic gradient descent",
				"   • Monte Carlo methods",
				"   • Reinforcement learning exploration",
				"   • Sampling algorithms",
				"",
				"Random walks are particularly useful because they're simple to implement but produce complex, natural-looking results."
			],
			"visualization": "random_walk_2d"
		},
		{
			"title": "Variations & Extensions",
			"text": [
				"Many interesting variations exist:",
				"",
				"1. Biased Random Walk:",
				"   • Tendency to move in certain directions",
				"   • Used for directed exploration",
				"",
				"2. Self-Avoiding Walk:",
				"   • Cannot revisit previous positions",
				"   • Creates more spread-out patterns",
				"",
				"3. Lévy Flight:",
				"   • Occasional large jumps mixed with small steps",
				"   • Models foraging behavior in nature",
				"",
				"4. Continuous Random Walk:",
				"   • Smooth angles instead of discrete directions",
				"   • More realistic movement patterns"
			],
			"visualization": "random_walk_2d"
		},
		{
			"title": "Performance Considerations",
			"text": [
				"When implementing random walks in games:",
				"",
				"• Store full paths only when needed (use ring buffers for trails)",
				"• For many walkers, update in batches",
				"• Consider using compute shaders for 1000+ simultaneous walks",
				"• Spatial hashing can optimize collision detection",
				"",
				"Complexity:",
				"• Time: O(1) per step",
				"• Space: O(N) for N-step trail",
				"",
				"For procedural generation, consider:",
				"• Seed your RNG for reproducible results",
				"• Test with different step counts to find desired characteristics",
				"• Combine with other algorithms (e.g., cellular automata)"
			],
			"visualization": "random_walk_2d"
		}
	]

func create_visualization(vis_type: String) -> Control:
	"""Create appropriate visualization for the given type"""
	match vis_type:
		"random_walk_2d":
			var vis = Control.new()
			vis.set_script(RandomWalkVis)
			vis.visualization_type = vis_type
			vis.custom_minimum_size = Vector2(400, 400)
			return vis
		_:
			return null
