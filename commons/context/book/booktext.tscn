[gd_scene format=3 uid="uid://cxa6km0tuu6j6"]

[node name="Node2D" type="Node2D"]

[node name="RichTextLabel" type="RichTextLabel" parent="."]
offset_left = 13.0
offset_top = 5.0
offset_right = 726.0
offset_bottom = 834.0
text = "Axiom 0 - It was already there
The prerequisite is what is already there. In the Virtual world The rendering system, the player's embodiment in the 3d dimensional coordinate system, time that runs every frame. All things that are part of representing our euclidean space and the time. We are thrown into space time before light. 
In our specific instance the framework we choose for Ada Research, the Godot game engine and the XR tool kit has functions that we want to use. That is part of the beauty of Open Source and also becomes part of the prerequisite. 
They are things of endless descent and it is always partly ignored. It is a function of time and makes space and the uncomputability of the world. It is all the things that we need to ignore now or for ever. Things we can not explain from the beginning,  things we have to return to when time permits, they are inherent backgrounds. 
-----
Lets imagine things that exist in the world and then translate them into code. In the beginning I want the world to be built by axioms.The Virtual World is built upon existing prerequisites: a rendering system, the player's embodiment within a 3D coordinate system, and time that advances with each frame. These elements collectively represent our Euclidean space and time, essentially \"throwing us into space-time before light.\"

For Ada Research, we've chosen the Godot game engine and the XR toolkit. Their functions, a benefit of open source, become part of our prerequisites. These foundational elements represent an endless descent of complexity, partly ignored, that define the uncomputability of the world. They are aspects we must currently overlook or forever. We cannot explain them from the outset and will return to them as time permits, as they form inherent backgrounds.

Our aim is to translate existing world elements into code, beginning with the world being built by axioms.

A point - Scene One 
We start with a point, that is the foreground, in front of the player in space. The atom. 
Axiom 1: A point in the 3d dimensional coordinate system is a vector representing a position in x, y, z. 
Code: 
var point_position = Vector3(0, 0, 0) 
The vector (0,0,0) is the origin and the root of all vectors. 

It sits in space and so far this point is not visible; it needs representation. 

What is a good size point in space not to feel like a sphere. How small should something be? 1 Godot unit is 1 meter. If the sphere point has a radius of 0.01 it is one centimeter. How does it feel? 
 
Axiom 2: A visible point can be represented by a small sphere at its position.

Code: 
var sphere_mesh = SphereMesh.new()
radius = 0.01 # a small sphere
sphere_mesh.radius = radius
sphere_mesh.height = radius * 2 # SphereMesh height is double radius 

Axiom 2.5: A mesh must be instantiated as a scene object to exist in the world. 

Code: 
var mesh_instance = MeshInstance3D.new()
mesh_instance.mesh = sphere_mesh
mesh_instance.position = point_position

add_child(mesh_instance)
Axiom 3: The identity of a point is represented as a text label close to the point.
var label_3d = Label3D.new()
label_3d.text = str(point_position)
off_set = Vector3(0, 0.15, 0)
label_3d.position = point_position + off_set
label_3d.billboard = BaseMaterial3D.BILLBOARD_ENABLED
add_child(label_3d)
Null check and parents

Axiom 4: The text label must update when the point's position changes.

func _process(delta):
    label_3d.text = str(point_position)
    label_3d.position = point_position + label_offset


Scene One: Defining a Point

We begin with a fundamental element: a point. In a 3D coordinate system, a point is a vector (x, y, z) representing a specific position. The origin, (0, 0, 0), serves as the root for all vectors.

Axiom 1: A point in 3D space is a vector that defines a position.

Code Example:
var point_position = Vector3(0, 0, 0)

Initially, this point is abstract and not visible. It requires a tangible representation within the space.

Considering Scale:
To avoid a point appearing as a sphere, its size needs careful consideration. In Godot, 1 unit equals 1 meter. A sphere with a radius of 0.01 (one centimeter) might still feel too large.

Axiom 2: A visible point can be represented by a small sphere at its designated position.

Code Example:
var sphere_mesh = SphereMesh.new()
radius = 0.01 # a small sphere
sphere_mesh.radius = radius
sphere_mesh.height = radius * 2 # SphereMesh height is double radius
Axiom 2.5: For a mesh to exist in the world, it must be instantiated as a scene object.

Code Example:
var mesh_instance = MeshInstance3D.new()
mesh_instance.mesh = sphere_mesh
mesh_instance.position = point_position
add_child(mesh_instance)
Axiom 3: The identity of a point is conveyed by a text label positioned near it.

Code Example:
var label_3d = Label3D.new()
label_3d.text = str(point_position)
off_set = Vector3(0, 0.15, 0)
label_3d.position = point_position + off_set
label_3d.billboard = BaseMaterial3D.BILLBOARD_ENABLED
add_child(label_3d)
Axiom 4: The text label must dynamically update to reflect any changes in the point's position.

Code Example:
func _process(delta):
    label_3d.text = str(point_position)
    label_3d.position = point_position + label_offset

Scene Two  - The line
Axiom 3: Distance between two points is the magnitude of 
"
