extends Node3D

const FISH_TANK_SCENE := preload("res://commons/primitives/fish_tank/fish_tank.tscn")
const CONTROLLER_SCENE := preload("res://spatial_ui/parameter_controller_3d.tscn")
const MAT_ACTIVE := preload("res://commons/resourses/materials/noc_vr/noc_vr_pink_primary.tres")
const MAT_INACTIVE := preload("res://commons/resourses/materials/noc_vr/noc_vr_pink_secondary.tres")

@export var rule_number: int = 30
@export var rows_visible: int = 32

const GRID_WIDTH := 64

var _sim_root: Node3D
var _cells: Array[Array[int]] = []
var _row_index: int = 0
var _row_nodes: Array[MeshInstance3D] = []
var _controller_root: Node3D
var _status_label: Label3D

func _ready() -> void:
	_setup_environment()
	_init_cells()
	_update_visuals()
	set_process(true)

func _setup_environment() -> void:
	_sim_root = Node3D.new()
	_sim_root.name = "SimulationRoot"
	add_child(_sim_root)

	var fish_tank := FISH_TANK_SCENE.instantiate()
	fish_tank.name = "FishTank"
	_sim_root.add_child(fish_tank)

	_status_label = Label3D.new()
	_status_label.billboard = BaseMaterial3D.BILLBOARD_ENABLED
	_status_label.font_size = 20
	_status_label.modulate = Color(1.0, 0.85, 1.0)
	_status_label.position = Vector3(0, 0.82, 0)
	_sim_root.add_child(_status_label)

	_create_controller()
	_update_status()

func _create_controller() -> void:
	_controller_root = Node3D.new()
	_controller_root.position = Vector3(0.75, 0.45, 0)
	add_child(_controller_root)

	var controller := CONTROLLER_SCENE.instantiate()
	controller.parameter_name = "Rule"
	controller.min_value = 0
	controller.max_value = 255
	controller.step_size = 1
	controller.default_value = rule_number
	controller.rotation_degrees = Vector3(0, 90, 0)
	_controller_root.add_child(controller)
	controller.value_changed.connect(func(v: float) -> void:
		rule_number = int(v)
		_reset()
	)
	controller.set_value(rule_number)

func _init_cells() -> void:
	_cells.clear()
	_cells.resize(rows_visible)
	for r in range(rows_visible):
		_cells[r] = []
		_cells[r].resize(GRID_WIDTH)
		for c in range(GRID_WIDTH):
			_cells[r][c] = 0

	_cells[0][GRID_WIDTH / 2] = 1
	_row_index = 1

	_create_row_meshes()

func _create_row_meshes() -> void:
	_row_nodes.clear()
	for r in range(rows_visible):
		var row := MeshInstance3D.new()
		var array_mesh := ArrayMesh.new()
		row.mesh = array_mesh
		row.position = Vector3(0, 0.1 + float(r) * 0.02, 0)
		_sim_root.add_child(row)
		_row_nodes.append(row)

func _process(delta: float) -> void:
	if _row_index < rows_visible:
		_generate_row(_row_index)
		_row_index += 1
		_update_visual(row_index = _row_index - 1)
	else:
		_scroll_rows()
	_generate_row(rows_visible - 1)
	_update_visual(row_index = rows_visible - 1)

func _generate_row(row_index: int) -> void:
	var previous := _cells[(row_index - 1 + rows_visible) % rows_visible]
	var current := _cells[row_index % rows_visible]
	for c in range(GRID_WIDTH):
		var left := previous[(c - 1 + GRID_WIDTH) % GRID_WIDTH]
		var center := previous[c]
		var right := previous[(c + 1) % GRID_WIDTH]
		var neighborhood := (left << 2) | (center << 1) | right
		var bit := (rule_number >> neighborhood) & 1
		current[c] = bit

func _scroll_rows() -> void:
	for r in range(rows_visible - 1):
		_cells[r] = _cells[r + 1]
	_update_visual(row_index = r)
	_cells[rows_visible - 1] = []
	_cells[rows_visible - 1].resize(GRID_WIDTH)

func _update_visuals() -> void:
	for r in range(rows_visible):
		_update_visual(r)

func _update_visual(row_index: int) -> void:
	var row := _cells[row_index]
	var array_mesh := ArrayMesh.new()
	var arrays := []
	var positions := PackedVector3Array()
	var colors := PackedColorArray()
	var cell_width := 0.9 / GRID_WIDTH
	for c in range(GRID_WIDTH):
		var state := row[c]
		if state == 0:
			continue
		var x := -0.45 + (float(c) / GRID_WIDTH)
		var y := 0
		var z := 0
		positions.append(Vector3(x, y, z))
		colors.append(Color(1.0, 0.7, 0.9, 1.0))

	var mesh := ImmediateMesh.new()
	mesh.surface_begin(Mesh.PRIMITIVE_QUADS)
	for c in range(GRID_WIDTH):
		if row[c] == 0:
			continue
		var x0 := -0.45 + c * cell_width
		var x1 := x0 + cell_width
		var y0 := 0
		var y1 := 0.015
		mesh.surface_set_color(Color(1.0, 0.7, 0.9))
		mesh.surface_add_vertex(Vector3(x0, y0, 0))
		mesh.surface_add_vertex(Vector3(x1, y0, 0))
		mesh.surface_add_vertex(Vector3(x1, y1, 0))
		mesh.surface_add_vertex(Vector3(x0, y1, 0))
	mesh.surface_end()

	_row_nodes[row_index].mesh = mesh

func _reset() -> void:
	_init_cells()
	_update_status()

func _update_status() -> void:
	_status_label.text = "Rule %d" % rule_number

class DNA:
	pass
