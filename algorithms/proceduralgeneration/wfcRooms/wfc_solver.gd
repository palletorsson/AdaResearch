## res://algorithms/proceduralgeneration/wfcRooms/wfc_solver.gd
## Runtime WFC (Wave Function Collapse) solver for room tiles
## Attach to a Node3D in your scene to generate procedural dungeons
extends Node3D

## Size of the dungeon grid
@export var grid_width : int = 10
@export var grid_height : int = 10
@export var tile_size : float = 2.0

## Path to the tile scene generated by wfc_rooms.gd
@export var tiles_scene_path : String = "res://algorithms/proceduralgeneration/wfcRooms/RoomTiles_Aligned.tscn"

## Generate on ready?
@export var auto_generate : bool = true

## Maximum iterations to prevent infinite loops
@export var max_iterations : int = 10000

## Seed for reproducible generation (-1 = random)
@export var generation_seed : int = -1

## Internal data
var tile_prototypes : Array[Node3D] = []
var grid : Array = []  # 2D array of placed tiles
var possible : Array = []  # 2D array of possible tiles per cell

## Socket compatibility cache
var socket_rules : Dictionary = {}

func _ready():
	if auto_generate:
		generate_dungeon()

## Main generation function
func generate_dungeon() -> bool:
	print("üèóÔ∏è Starting WFC dungeon generation...")
	
	# Setup random seed
	if generation_seed >= 0:
		seed(generation_seed)
	
	# Load tile prototypes
	if not _load_tile_prototypes():
		push_error("Failed to load tile prototypes!")
		return false
	
	# Initialize grid
	_initialize_grid()
	
	# Run WFC algorithm
	var success = _collapse_wave_function()
	
	if success:
		print("‚úÖ Dungeon generated successfully!")
		_place_tiles_in_world()
		return true
	else:
		push_error("‚ùå WFC failed to find valid solution")
		return false

## Load all tile prototypes from the generated scene
func _load_tile_prototypes() -> bool:
	var scene = load(tiles_scene_path)
	if not scene:
		push_error("‚ùå Could not load tiles scene: " + tiles_scene_path)
		push_error("üí° TIP: Run wfc_rooms.gd first to generate tiles!")
		push_error("   1. Open wfc_rooms.gd in Script Editor")
		push_error("   2. Click File ‚Üí Run (Ctrl+Shift+X)")
		push_error("   3. This creates algorithms/proceduralgeneration/wfcRooms/RoomTiles_Aligned.tscn")
		_create_fallback_grid()
		return false
	
	var root = scene.instantiate()
	
	# Find all tiles (they're in the "tile" group)
	for child in root.get_children():
		if child.is_in_group("tile") and child is Node3D:
			tile_prototypes.append(child)
	
	if tile_prototypes.is_empty():
		push_error("No tiles found in scene!")
		root.queue_free()
		return false
	
	print("üì¶ Loaded ", tile_prototypes.size(), " tile types")
	
	# Build socket compatibility rules
	_build_socket_rules()
	
	# Don't add root to scene, just use it as template
	root.queue_free()
	
	return true

## Build rules for which tiles can be adjacent
func _build_socket_rules():
	socket_rules.clear()
	
	for tile in tile_prototypes:
		var sockets = tile.get_meta("sockets", {})
		socket_rules[tile.name] = sockets
	
	print("üìã Built socket rules for ", socket_rules.size(), " tiles")

## Initialize the grid with all possibilities
func _initialize_grid():
	grid = []
	possible = []
	
	for y in range(grid_height):
		var row = []
		var poss_row = []
		for x in range(grid_width):
			row.append(null)
			# Initially, all tiles are possible at each position
			poss_row.append(tile_prototypes.duplicate())
		grid.append(row)
		possible.append(poss_row)
	
	print("üåê Initialized grid: ", grid_width, "x", grid_height)

## Core WFC algorithm
func _collapse_wave_function() -> bool:
	var iterations = 0
	
	while not _is_fully_collapsed():
		iterations += 1
		if iterations > max_iterations:
			push_error("Max iterations reached!")
			return false
		
		# Find cell with minimum entropy (fewest possibilities)
		var coords = _find_min_entropy_cell()
		if coords == null:
			# No valid cells = contradiction
			return false
		
		var x = coords.x
		var y = coords.y
		
		# Collapse this cell (choose random tile from possibilities)
		var poss = possible[y][x]
		if poss.is_empty():
			# Contradiction
			return false
		
		var chosen_tile = poss[randi() % poss.size()]
		grid[y][x] = chosen_tile
		possible[y][x] = []
		
		# Propagate constraints to neighbors
		_propagate_constraints(x, y)
		
		if iterations % 100 == 0:
			print("Iteration ", iterations, " - ", _count_collapsed(), "/", grid_width * grid_height, " cells collapsed")
	
	print("‚úÖ WFC completed in ", iterations, " iterations")
	return true

## Find the uncollapsed cell with fewest possibilities
func _find_min_entropy_cell():
	var min_entropy = INF
	var candidates = []
	
	for y in range(grid_height):
		for x in range(grid_width):
			if grid[y][x] == null:  # Not collapsed
				var entropy = possible[y][x].size()
				if entropy == 0:
					# Contradiction found
					return null
				if entropy < min_entropy:
					min_entropy = entropy
					candidates = [Vector2i(x, y)]
				elif entropy == min_entropy:
					candidates.append(Vector2i(x, y))
	
	if candidates.is_empty():
		return null
	
	# Pick random cell among those with minimum entropy
	return candidates[randi() % candidates.size()]

## Propagate constraints after collapsing a cell
func _propagate_constraints(start_x: int, start_y: int):
	var stack = [Vector2i(start_x, start_y)]
	
	while not stack.is_empty():
		var coord = stack.pop_back()
		var x = coord.x
		var y = coord.y
		
		# Check all 4 neighbors
		var neighbors = [
			{"pos": Vector2i(x, y - 1), "dir": "N", "opp": "S"},  # North
			{"pos": Vector2i(x + 1, y), "dir": "E", "opp": "W"},  # East
			{"pos": Vector2i(x, y + 1), "dir": "S", "opp": "N"},  # South
			{"pos": Vector2i(x - 1, y), "dir": "W", "opp": "E"},  # West
		]
		
		for neighbor in neighbors:
			var nx = neighbor.pos.x
			var ny = neighbor.pos.y
			
			# Skip if out of bounds
			if nx < 0 or nx >= grid_width or ny < 0 or ny >= grid_height:
				continue
			
			# Skip if already collapsed
			if grid[ny][nx] != null:
				continue
			
			# Filter possibilities for this neighbor
			var old_count = possible[ny][nx].size()
			_constrain_cell(nx, ny, x, y, neighbor.dir, neighbor.opp)
			var new_count = possible[ny][nx].size()
			
			# If possibilities changed, propagate further
			if new_count < old_count:
				stack.append(Vector2i(nx, ny))

## Constrain a cell based on its neighbor
func _constrain_cell(cell_x: int, cell_y: int, neighbor_x: int, neighbor_y: int, direction: String, opposite: String):
	var neighbor_tile = grid[neighbor_y][neighbor_x]
	
	# If neighbor is collapsed, filter based on its socket
	if neighbor_tile != null:
		var neighbor_sockets = socket_rules.get(neighbor_tile.name, {})
		var required_socket = neighbor_sockets.get(opposite, "")
		
		# Remove tiles that don't match
		var filtered = []
		for tile in possible[cell_y][cell_x]:
			var tile_sockets = socket_rules.get(tile.name, {})
			if tile_sockets.get(direction, "") == required_socket:
				filtered.append(tile)
		
		possible[cell_y][cell_x] = filtered
	
	# If neighbor still has possibilities, ensure at least one compatible tile exists
	else:
		var neighbor_poss = possible[neighbor_y][neighbor_x]
		var filtered = []
		
		for tile in possible[cell_y][cell_x]:
			var tile_sockets = socket_rules.get(tile.name, {})
			var my_socket = tile_sockets.get(direction, "")
			
			# Check if any neighbor possibility is compatible
			var has_compatible = false
			for n_tile in neighbor_poss:
				var n_sockets = socket_rules.get(n_tile.name, {})
				if n_sockets.get(opposite, "") == my_socket:
					has_compatible = true
					break
			
			if has_compatible:
				filtered.append(tile)
		
		possible[cell_y][cell_x] = filtered

## Check if all cells are collapsed
func _is_fully_collapsed() -> bool:
	for y in range(grid_height):
		for x in range(grid_width):
			if grid[y][x] == null:
				return false
	return true

## Count collapsed cells
func _count_collapsed() -> int:
	var count = 0
	for y in range(grid_height):
		for x in range(grid_width):
			if grid[y][x] != null:
				count += 1
	return count

## Place the generated tiles in the 3D world
func _place_tiles_in_world():
	# Clear existing children (except camera/lights)
	for child in get_children():
		if child.is_in_group("generated_tile"):
			child.queue_free()
	
	# Place tiles
	for y in range(grid_height):
		for x in range(grid_width):
			var tile_proto = grid[y][x]
			if tile_proto == null:
				continue
			
			# Instance the tile
			var tile = tile_proto.duplicate()
			tile.add_to_group("generated_tile")
			
			# Position it in world
			tile.transform.origin = Vector3(x * tile_size, 0, y * tile_size)
			
			add_child(tile)
	
	print("üé® Placed ", grid_width * grid_height, " tiles in world")

## Public function to regenerate with new seed
func regenerate(new_seed: int = -1):
	if new_seed >= 0:
		generation_seed = new_seed
	else:
		generation_seed = randi()
	
	generate_dungeon()

## Get tile at grid position
func get_tile_at(x: int, y: int) -> Node3D:
	if x < 0 or x >= grid_width or y < 0 or y >= grid_height:
		return null
	return grid[y][x]

## Debug: Print grid layout
func print_grid():
	print("Grid layout:")
	for y in range(grid_height):
		var row = ""
		for x in range(grid_width):
			var tile = grid[y][x]
			if tile:
				row += tile.name[0] + " "
			else:
				row += "? "
		print(row)

## Create a simple fallback grid when tiles aren't available
func _create_fallback_grid():
	print("üì¶ Creating fallback grid visualization...")
	
	for y in range(grid_height):
		for x in range(grid_width):
			# Create simple box at each grid position
			var box = CSGBox3D.new()
			box.name = "FallbackTile_%d_%d" % [x, y]
			box.size = Vector3(tile_size * 0.9, 0.2, tile_size * 0.9)
			box.transform.origin = Vector3(x * tile_size, 0, y * tile_size)
			
			# Checker pattern coloring
			var is_dark = (x + y) % 2 == 0
			var mat = StandardMaterial3D.new()
			mat.albedo_color = Color(0.7, 0.7, 0.8) if is_dark else Color(0.5, 0.5, 0.6)
			box.material = mat
			
			box.add_to_group("generated_tile")
			add_child(box)
	
	# Add helpful label
	var label = Label3D.new()
	label.text = "‚ö†Ô∏è Fallback Grid - Tiles Not Found\n\n1. Open wfc_rooms.gd\n2. Run it (Ctrl+Shift+X)\n3. Reload this scene"
	label.font_size = 32
	label.outline_size = 8
	label.transform.origin = Vector3(grid_width * tile_size * 0.5, 2, -5)
	add_child(label)
	
	print("‚úÖ Fallback grid created - ", grid_width * grid_height, " tiles")
